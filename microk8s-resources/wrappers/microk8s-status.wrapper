#!/usr/bin/env python3

import yaml
import os
import subprocess
import sys
import time
import platform
import argparse
import getpass

# architecture mapping
arch_mapping = {
    'aarch64': 'arm64',
    'x86_64': 'amd64'
}

current_arch = arch_mapping[platform.machine()]
snap_data = os.environ["SNAP_DATA"]
snap_dir = os.environ["SNAP"]
kubeconfig = "--kubeconfig="+ os.path.expandvars("${SNAP_DATA}/credentials/client.config")
console_formatter = "{:>1} {:<20} # {}"

# define the program description
text = 'Microk8s cluster status check.'

# initiate the parser with a description
parser = argparse.ArgumentParser(description = text)
parser.add_argument("-o", "--output", help="Print cluster and addon status, output can be in yaml or console", default="console", choices={"console", "yaml"})
parser.add_argument("-w", "--wait-ready", help="Wait until the cluster is in ready state", nargs='?', const=True, type=bool)
parser.add_argument("-t", "--timeout", help="Specify a timeout in seconds when waiting for the cluster to be ready.", type=int, default=0)
# read arguments from the command line
args = parser.parse_args()

CYAN = '\033[36m'
YELLOW = '\033[93m'
ENDC = '\033[0m'

def cyan_output(message):
    print(CYAN + message + ENDC)

def yellow_output(message):
    print(YELLOW + message + ENDC)

def exit_if_no_permission():
    user = getpass.getuser()
    # test if we can access the default kubeconfig
    clientConfigFile = os.path.expandvars("${SNAP_DATA}/credentials/client.config")
    if os.access(clientConfigFile, os.R_OK) == False:
        print ("Insufficient permissions to access MicroK8s.")
        print ("You can either try again with sudo or add the user {} to the 'microk8s' group:".format(user))
        print ("")
        print ("    sudo usermod -a -G microk8s {}".format(user))
        print ("")
        print ("The new group will be available on the user's next login.")
        exit(1)  
addon[helm3]="${SNAP_DATA}/bin/helm3"


def is_cluster_locked():
    clusterLockFile = os.path.expandvars("${SNAP_DATA}/var/lock/clustered.lock")
    if os.path.isfile(clusterLockFile):
        print("This MicroK8s deployment is acting as a node in a cluster. Please use the microk8s.status on the master.")
        exit(0)


def run(*args, die=True):
    # Add wrappers to $PATH
    env = os.environ.copy()
    env["PATH"] += ":%s" % os.environ["SNAP"]
    result = subprocess.run(
        args,
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        env=env
    )

    try:
        result.check_returncode()
    except subprocess.CalledProcessError as err:
        if die:
            if result.stderr:
                print(result.stderr.decode("utf-8"))
            print(err)
            sys.exit(1)
        else:
            raise

    return result.stdout.decode("utf-8")

def is_cluster_ready():
    try:
        service_output = kubectl_get("all")
        node_output = kubectl_get("nodes")
        if "Ready" in node_output and "service/kubernetes" in  service_output:
            return True
        else:
            return False
    except Exception:
        return False


def wait_for_ready(wait_ready,timeout):
    start_time = time.time()
    isReady = False

    while True :
        if (timeout >0 and (time.time() > (start_time + timeout))) or isReady:
            break
        try:
            isReady = is_cluster_ready()
        except Exception:
            time.sleep(2)
    
    return isReady


def get_available_addons(arch, addon_dataset):
    available = []
    with open(addon_dataset, 'r') as file:
        # The FullLoader parameter handles the conversion from YAML
        # scalar values to Python the dictionary format
        addons = yaml.load(file, Loader=yaml.FullLoader)
        for addon in addons["microk8s-addons"]["addons"]:
            if arch in addon["supported_architectures"]:
               available.append(addon)
    
    available = sorted(available, key=lambda k: k['name'])                  
    return available


def kubectl_get(cmd, namespace="--all-namespaces"):
    if namespace == "--all-namespaces":
        return run("kubectl", kubeconfig, "get", cmd, "--all-namespaces", die=False)
    else:
        return run("kubectl", kubeconfig, "get", cmd, "-n", namespace, die=False)


def kubectl_get_clusterroles():
    return run("kubectl", kubeconfig, "get", "clusterroles", "--show-kind","--no-headers", die=False)


def is_enabled(addon, item):
    if addon in item:
        return True
    else:
        filePath = os.path.expandvars(addon)
        return os.path.isfile(filePath)
    
    return False

def print_console(isReady, enabled_addons, disabled_addons):
    if isReady:
        print("microk8s is running")
    else:
        print("microk8s is not running. Use microk8s.inspect for a deeper inspection.")

    if isReady:    
        print("addons:")
        print('{:>2}'.format("enabled:"))
        for enabled in enabled_addons:
            cyan_output(console_formatter.format("", enabled["name"], enabled["description"]))
        print("")   
        print('{:>2}'.format("disabled:"))
        for disabled in disabled_addons:
            yellow_output(console_formatter.format("", disabled["name"], disabled["description"]))


def print_yaml(isReady, enabled_addons, disabled_addons):
        
    print("microk8s:")
    print("{:>2} {} {}".format("", "running:", isReady))

    if not isReady:
        print("{:>2} {} {}".format("","message:","microk8s is not running. Use microk8s.inspect for a deeper inspection."))
        return

    if isReady:    
        print("{:>2}".format("addons:"))
        print('{:>4}{}'.format("", "enabled:"))
        for enabled in enabled_addons:
            print("{:>6} name: {:<1}".format("-", enabled["name"]))
            print("{:>6} description: {:<1}".format("", enabled["description"]))
            print("{:>6} version: {:<1}".format("", enabled["version"]))
            
        print('{:>4}{}'.format("","disabled:"))
        for disabled in disabled_addons:
            print("{:>6} name: {:<1}".format("-", disabled["name"]))
            print("{:>6} description: {:<1}".format("", disabled["description"]))
            print("{:>6} version: {:<1}".format("", disabled["version"]))


def get_status(output, isReady):
    addon_dataset = snap_dir + "/addon-lists.yaml"
    enabled = []
    disabled = []
    
    if isReady:
        available_addons = get_available_addons(current_arch, addon_dataset)
        kube_output = kubectl_get("all")
        cluster_output = kubectl_get_clusterroles()
        kube_output = kube_output + cluster_output
        for addon in available_addons:
            found = False
            for row in kube_output.split('\n'):
                if is_enabled(addon["check_status"], row) == True:
                    enabled.append(addon)
                    found = True
                    break
            
            if found == False:
                disabled.append(addon)
    
    if output == "yaml":
        print_yaml(isReady, enabled, disabled)
    else:
        print_console(isReady, enabled, disabled)

# Start here
exit_if_no_permission()
is_cluster_locked()

wait_ready = args.wait_ready
timeout = args.timeout

if wait_ready == True:
    isReady = wait_for_ready(wait_ready, timeout )
else:
    isReady = is_cluster_ready()

get_status(args.output, isReady)
