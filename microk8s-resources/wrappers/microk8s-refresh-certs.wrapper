#!/bin/bash

set -eu

export PATH="$SNAP/usr/sbin:$SNAP/usr/bin:$SNAP/sbin:$SNAP/bin:$PATH"
source $SNAP/actions/common/utils.sh

if [ -e ${SNAP_DATA}/var/lock/clustered.lock ]
then
  echo "This MicroK8s deployment is acting as a node in a cluster. Please use the microk8s refresh-certs command on the master"
  echo "and then return to this node to perform a microk8s leave and re-join."
  exit 0
fi

exit_if_no_permissions

BACKUP=$SNAP_DATA/var/log/ca-backup/
INSTALL=false
UNDO=false
CHECK=false
REFRESH=false
PARSED=$(getopt --options=iuhcr: --longoptions=install,undo,help,check,refresh: --name "refresh-certs" -- "$@")
eval set -- "$PARSED"
while true; do
  case "$1" in
    -i|--install)
        INSTALL=true
        shift
        ;;
    -u|--undo)
        UNDO=true
        shift
        ;;
    -c|--check)
        CHECK=true
        shift
        ;;
    -r|--refresh)
        REFRESH=true
        CAPATH=$2
        shift 2
        ;;
    -h|--help)
        echo "Usage: $0 [OPTIONS]"
        echo
        echo "Refresh the CA certificates in this deployment"
        echo
        echo "Options:"
        echo " -h, --help          Show this help"
        echo " -u, --undo          Revert the last refresh performed"
        echo " -c, --check         Check the expiration time of the installed CA"
        echo " -r, --refresh path  Change CA cert and key"
        echo " -i, --install       Install new CA certificates"
        exit 0
        ;;
    --)
        shift
        break
        ;;
    *)
        echo "$0: invalid option -- $1"
        exit 1
  esac
done


function revert {
  if ! [ -d "$BACKUP" ]
  then
    echo "No previous backup found"
    exit 1
  fi

  echo "Reverting certificates"
  run_with_sudo cp -r $BACKUP/certs/ ${SNAP_DATA}/
  run_with_sudo cp -r $BACKUP/credentials/ ${SNAP_DATA}/

  echo "Restarting"
  $SNAP/microk8s-stop.wrapper || true
  $SNAP/microk8s-start.wrapper
}

function check_ca_crt_dates {
    # parse date range in certificate
    IFS=$'\n'
    date_range=()
    for line in $(openssl x509 -noout -in ${CAPATH}/ca.crt -dates | sed -e 's/^.*=//')
    do
        dt=$(date "+%s" -d "$line")
        date_range+=("${dt}")
    done
    unset IFS

    # compare current date with date range in certificate
    date_now=$(date "+%s")
    test ${date_now} -gt ${date_range[0]}
    exit_if "Certificate is valid in the future but not now"
    test ${date_range[1]} -gt ${date_now}
    exit_if "Certificate has expired"
}

function exit_if {
    if [ $? -ne 0 ]; then
        echo "$1"
        exit 1
    fi;
}

function validate_ca_crt_and_key {
    # Check CA private key
    openssl rsa -in "${CAPATH}/ca.key" -check -noout -out /dev/null 2>/dev/null
    exit_if "CA Private key is invalid"

    # Check CA certificate
    openssl x509 -in "${CAPATH}/ca.crt" -text -noout -out /dev/null > /dev/null
    exit_if "CA certificate is invalid"

    # Check that CA private key matches CA certificate
    md5cert=$(openssl x509 -noout -modulus -in ${CAPATH}/ca.crt | openssl md5)
    md5key=$(openssl rsa -noout -modulus -in ${CAPATH}/ca.key | openssl md5)
    test "$md5cert" = "$md5key"
    exit_if "CA Private Key does not match CA Certifiate"

    # Verify that the public keys contained in the CA private key file and the CA certificate are the same
    md5cert=$(openssl x509 -in "${CAPATH}/ca.crt" -noout -pubkey | openssl md5)
    md5key=$(openssl rsa -in "${CAPATH}/ca.key" -pubout 2>&1 | grep -v 'writing RSA key' | openssl md5)
    test "$md5cert" = "$md5key"
    exit_if "CA Public key does not match CA Certifiate"

    # Check certificate date is currently valid
    check_ca_crt_dates
}

function backup_ca_crt_and_key {
  echo "Backing up CA cert and key under $BACKUP"
  run_with_sudo mkdir -p "${BACKUP}"

  if [ -e "${SNAP_DATA}/certs/ca.crt" ]
  then
      run_with_sudo cp "${SNAP_DATA}/certs/ca.crt" "$BACKUP"
  fi

  if [ -e "${SNAP_DATA}/certs/ca.key" ]
  then
      run_with_sudo cp "${SNAP_DATA}/certs/ca.key" "$BACKUP"
  fi
}

function refresh_ca {
  if [ -e "${CAPATH}/ca.crt" ] && [ -e "${CAPATH}/ca.key" ]
  then
      # validate CA certificate and CA key
      validate_ca_crt_and_key

      # backup CA certificate and CA key
      backup_ca_crt_and_key

      echo "Removing old CA certificate and key"
      run_with_sudo rm -f "${SNAP_DATA}/certs/ca.crt"
      run_with_sudo rm -f "${SNAP_DATA}/certs/ca.key"

      echo "Copying new CA certificate and key"
      run_with_sudo cp "${CAPATH}/ca.crt" "${SNAP_DATA}/certs/ca.crt"
      run_with_sudo cp "${CAPATH}/ca.key" "${SNAP_DATA}/certs/ca.key"
      run_with_sudo chgrp microk8s "${SNAP_DATA}/certs/ca.crt"
      run_with_sudo chgrp microk8s "${SNAP_DATA}/certs/ca.key"
  else
      echo "Could not find ca.crt and ca.key in $CAPATH, aborting CA certificate update"
      exit 1
  fi

  echo "Generating auxilary certificates"
  gen_server_cert
  echo "Restarting "
  update_configs
}

function refresh {
  # Backup
  echo "Backing up certificates under $BACKUP"
  run_with_sudo mkdir -p $SNAP_DATA/var/log/ca-backup/
  run_with_sudo cp -r ${SNAP_DATA}/certs $BACKUP
  run_with_sudo cp -r ${SNAP_DATA}/credentials $BACKUP/

  echo "Creating new certificates"
  run_with_sudo rm -rf ${SNAP_DATA}/certs/ca.crt
  run_with_sudo rm -rf ${SNAP_DATA}/certs/front-proxy-ca.crt
  run_with_sudo rm -rf ${SNAP_DATA}/certs/csr.conf
  produce_certs
  rm -rf .srl

  update_configs
}

function update_configs {
  # Create the basic tokens
  echo "Creating new kubeconfig file"
  ca_data=$(cat ${SNAP_DATA}/certs/ca.crt | ${SNAP}/usr/bin/base64 -w 0)

  # Create the client kubeconfig
  run_with_sudo cp ${SNAP}/client.config.template ${SNAP_DATA}/credentials/client.config
  $SNAP/bin/sed -i 's/CADATA/'"${ca_data}"'/g' ${SNAP_DATA}/credentials/client.config
  $SNAP/bin/sed -i 's/NAME/admin/g' ${SNAP_DATA}/credentials/client.config
  if grep admin ${SNAP_DATA}/credentials/known_tokens.csv 2>&1 > /dev/null
  then
    admin_token=`grep admin ${SNAP_DATA}/credentials/known_tokens.csv | cut -d, -f1`
    $SNAP/bin/sed -i 's/AUTHTYPE/token/g' ${SNAP_DATA}/credentials/client.config
    $SNAP/bin/sed -i '/username/d' ${SNAP_DATA}/credentials/client.config
  else
    admin_token=`grep admin ${SNAP_DATA}/credentials/basic_auth.csv | cut -d, -f1`
    $SNAP/bin/sed -i 's/AUTHTYPE/password/g' ${SNAP_DATA}/credentials/client.config
  fi
  $SNAP/bin/sed -i 's/PASSWORD/'"${admin_token}"'/g' ${SNAP_DATA}/credentials/client.config

  # Create the known tokens
  proxy_token=`grep kube-proxy ${SNAP_DATA}/credentials/known_tokens.csv | cut -d, -f1`
  hostname=$(hostname)
  kubelet_token=`grep kubelet-0 ${SNAP_DATA}/credentials/known_tokens.csv | cut -d, -f1`
  controller_token=`grep kube-controller-manager ${SNAP_DATA}/credentials/known_tokens.csv | cut -d, -f1`
  scheduler_token=`grep kube-scheduler ${SNAP_DATA}/credentials/known_tokens.csv | cut -d, -f1`

  # Create the client kubeconfig for the controller
  run_with_sudo cp ${SNAP}/client.config.template ${SNAP_DATA}/credentials/controller.config
  $SNAP/bin/sed -i 's/CADATA/'"${ca_data}"'/g' ${SNAP_DATA}/credentials/controller.config
  $SNAP/bin/sed -i 's/NAME/controller/g' ${SNAP_DATA}/credentials/controller.config
  $SNAP/bin/sed -i '/username/d' ${SNAP_DATA}/credentials/controller.config
  $SNAP/bin/sed -i 's/AUTHTYPE/token/g' ${SNAP_DATA}/credentials/controller.config
  $SNAP/bin/sed -i 's/PASSWORD/'"${controller_token}"'/g' ${SNAP_DATA}/credentials/controller.config

  # Create the client kubeconfig for the scheduler
  run_with_sudo cp ${SNAP}/client.config.template ${SNAP_DATA}/credentials/scheduler.config
  $SNAP/bin/sed -i 's/CADATA/'"${ca_data}"'/g' ${SNAP_DATA}/credentials/scheduler.config
  $SNAP/bin/sed -i 's/NAME/scheduler/g' ${SNAP_DATA}/credentials/scheduler.config
  $SNAP/bin/sed -i '/username/d' ${SNAP_DATA}/credentials/scheduler.config
  $SNAP/bin/sed -i 's/AUTHTYPE/token/g' ${SNAP_DATA}/credentials/scheduler.config
  $SNAP/bin/sed -i 's/PASSWORD/'"${scheduler_token}"'/g' ${SNAP_DATA}/credentials/scheduler.config

  # Create the proxy and kubelet kubeconfig
  run_with_sudo cp ${SNAP}/client.config.template ${SNAP_DATA}/credentials/kubelet.config
  $SNAP/bin/sed -i 's/NAME/kubelet/g' ${SNAP_DATA}/credentials/kubelet.config
  $SNAP/bin/sed -i 's/CADATA/'"${ca_data}"'/g' ${SNAP_DATA}/credentials/kubelet.config
  $SNAP/bin/sed -i '/username/d' ${SNAP_DATA}/credentials/kubelet.config
  $SNAP/bin/sed -i 's/AUTHTYPE/token/g' ${SNAP_DATA}/credentials/kubelet.config
  $SNAP/bin/sed -i 's/PASSWORD/'"${kubelet_token}"'/g' ${SNAP_DATA}/credentials/kubelet.config

  run_with_sudo cp ${SNAP}/client.config.template ${SNAP_DATA}/credentials/proxy.config
  $SNAP/bin/sed -i 's/NAME/kubeproxy/g' ${SNAP_DATA}/credentials/proxy.config
  $SNAP/bin/sed -i 's/CADATA/'"${ca_data}"'/g' ${SNAP_DATA}/credentials/proxy.config
  $SNAP/bin/sed -i '/username/d' ${SNAP_DATA}/credentials/proxy.config
  $SNAP/bin/sed -i 's/AUTHTYPE/token/g' ${SNAP_DATA}/credentials/proxy.config
  $SNAP/bin/sed -i 's/PASSWORD/'"${proxy_token}"'/g' ${SNAP_DATA}/credentials/proxy.config

  $SNAP/microk8s-stop.wrapper || true
  $SNAP/microk8s-start.wrapper

  echo ""
  echo "The CA certificates have been replaced. Kubernetes will restart the pods of your workloads."
  echo "Any worker nodes you may have in your cluster need to be removed and re-joined to become aware of the new CA."
  echo ""
}

if [[ "$UNDO" == "true" ]]
then
  revert
  exit
elif [[ "$CHECK" == "true" ]]
then
  exp_date_str="$(openssl x509 -enddate -noout -in $SNAP_DATA/certs/ca.crt | cut -d= -f 2)"
  exp_date_secs="$(date -d "$exp_date_str" +%s)"
  now_secs=$(date +%s)
  difference=$(($exp_date_secs-$now_secs))
  days=$(($difference/(3600*24)))
  echo "The CA certificate will expire in $days days."
  exit 0
elif [[ "$INSTALL" == "true" ]]
then
  refresh
  exit 0
elif [[ "$REFRESH" == "true" ]]
then
  refresh_ca
  exit 0
else
  echo "Use the --help to see the available options."
fi
